<h1>ISteamNetworking Interface</h1>
Networking functions for making connections and sending data between clients, traversing NATs when
possible.<br />
<br />
<strong>NOTE</strong>: This API is deprecated and may be removed in a future Steamworks SDK release.
Please use <a href="/doc/api/ISteamNetworkingSockets">ISteamNetworkingSockets</a> or
<a href="/doc/api/ISteamNetworkingMessages">ISteamNetworkingMessages</a> instead. See the
<a href="/doc/features/multiplayer/networking">Steam Networking</a> overview for more information.
<h2 class="bb_section"><a name="functions"></a>Member Functions</h2>
Member functions for <code class="bb_code bb_code_inline nohighlight">ISteamNetworking</code> are
called through the global accessor function
<code class="bb_code bb_code_inline nohighlight">SteamNetworking()</code>.
<h2 class="bb_subsection"><a name="AcceptP2PSessionWithUser"></a>AcceptP2PSessionWithUser</h2>
<div class="bb_code cpp">bool AcceptP2PSessionWithUser( CSteamID steamIDRemote );</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>steamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a></td>
            <td>The Steam ID of the user that sent the initial packet to us.</td>
        </tr>
    </tbody>
</table>
<br />
This allows the game to specify accept an incoming packet. This needs to be called before a real
connection is established to a remote host, the game will get a chance to say whether or not the
remote user is allowed to talk to them.<br />
<br />
When a remote user that you haven't sent a packet to recently, tries to first send you a packet,
your game will receive a callback
<a href="/doc/api/ISteamNetworking#P2PSessionRequest_t">P2PSessionRequest_t</a>. This callback
contains the Steam ID of the user who wants to send you a packet. In response to this callback,
you'll want to see if it's someone you want to talk to (for example, if they're in a lobby with
you), and if so, accept the connection; otherwise if you don't want to talk to the user, just ignore
the request. If the user continues to send you packets, another
<a href="/doc/api/ISteamNetworking#P2PSessionRequest_t">P2PSessionRequest_t</a> will be posted
periodically. If you've called
<a href="/doc/api/ISteamNetworking#SendP2PPacket">ISteamNetworking::SendP2PPacket</a> on the other
user, this implicitly accepts the session request.<br />
<br />
Note that this call should only be made in response to a
<a href="/doc/api/ISteamNetworking#P2PSessionRequest_t">P2PSessionRequest_t</a> callback!<br />
<br />
<strong>Returns:</strong> bool<br />
<strong>true</strong> upon success; <strong>false</strong> only if
<code class="bb_code bb_code_inline nohighlight">steamIDRemote</code> is invalid.
<h2 class="bb_subsection"><a name="AllowP2PPacketRelay"></a>AllowP2PPacketRelay</h2>
<div class="bb_code cpp">bool AllowP2PPacketRelay( bool bAllow );</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>bAllow</strong></td>
            <td>bool</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Allow or disallow P2P connections to fall back to being relayed through the Steam servers if a
direct connection or NAT-traversal cannot be established.<br />
<br />
This only applies to connections created after setting this value, or to existing connections that
need to automatically reconnect after this value is set.<br />
<br />
P2P packet relay is allowed by default.<br />
<br />
<strong>Returns:</strong> bool<br />
This function always returns <strong>true</strong>.
<h2 class="bb_subsection"><a name="CloseP2PChannelWithUser"></a>CloseP2PChannelWithUser</h2>
<div class="bb_code cpp">bool CloseP2PChannelWithUser( CSteamID steamIDRemote, int nChannel );</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>steamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a></td>
            <td>The Steam ID of the user to close the connection with.</td>
        </tr>
        <tr>
            <td><strong>nChannel</strong></td>
            <td>int</td>
            <td>The channel to close.</td>
        </tr>
    </tbody>
</table>
<br />
Closes a P2P channel when you're done talking to a user on the specific channel.<br />
<br />
Once all channels to a user have been closed, the open session to the user will be closed and new
data from this user will trigger a new
<a href="/doc/api/ISteamNetworking#P2PSessionRequest_t">P2PSessionRequest_t</a> callback.<br />
<br />
<strong>Returns:</strong> bool<br />
<strong>true</strong> if the channel was successfully closed; otherwise, <strong>false</strong> if
there was no active session or channel with the user.
<h2 class="bb_subsection"><a name="CloseP2PSessionWithUser"></a>CloseP2PSessionWithUser</h2>
<div class="bb_code cpp">bool CloseP2PSessionWithUser( CSteamID steamIDRemote );</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>steamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a></td>
            <td>The Steam ID of the user to close the connection with.</td>
        </tr>
    </tbody>
</table>
<br />
This should be called when you're done communicating with a user, as this will free up all of the
resources allocated for the connection under-the-hood.<br />
<br />
If the remote user tries to send data to you again, a new
<a href="/doc/api/ISteamNetworking#P2PSessionRequest_t">P2PSessionRequest_t</a> callback will be
posted.<br />
<br />
<strong>Returns:</strong> bool<br />
<strong>true</strong> if the session was successfully closed; otherwise, <strong>false</strong> if
no connection was open with <code class="bb_code bb_code_inline nohighlight">steamIDRemote</code>.
<h2 class="bb_subsection"><a name="CreateConnectionSocket"></a>CreateConnectionSocket</h2>
<div class="bb_code cpp">
    SNetSocket_t CreateConnectionSocket( uint32 nIP, uint16 nPort, int nTimeoutSec );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>nIP</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>nPort</strong></td>
            <td><a href="/doc/api/steam_api#uint16">uint16</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>nTimeoutSec</strong></td>
            <td>int</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Creates a socket and begin connection to a remote destination.<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model. It's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> <a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a>
<h2 class="bb_subsection"><a name="CreateListenSocket"></a>CreateListenSocket</h2>
<div class="bb_code cpp">
    SNetListenSocket_t CreateListenSocket( int nVirtualP2PPort, uint32 nIP, uint16 nPort, bool
    bAllowUseOfPacketRelay );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>nVirtualP2PPort</strong></td>
            <td>int</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>nIP</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>nPort</strong></td>
            <td><a href="/doc/api/steam_api#uint16">uint16</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>bAllowUseOfPacketRelay</strong></td>
            <td>bool</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Creates a socket and listens others to connect.<br />
<br />
Will trigger a
<a href="/doc/api/ISteamNetworking#SocketStatusCallback_t">SocketStatusCallback_t</a> callback on
another client connecting.<br />
<br />
nVirtualP2PPort is the unique ID that the client will connect to, in case you have multiple ports<br />
this can usually just be 0 unless you want multiple sets of connections<br />
unIP is the local IP address to bind to<br />
pass in 0 if you just want the default local IP<br />
unPort is the port to use<br />
pass in 0 if you don't want users to be able to connect via IP/Port, but expect to be always
peer-to-peer connections only<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model. It's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong>
<a href="/doc/api/ISteamNetworking#SNetListenSocket_t">SNetListenSocket_t</a>
<h2 class="bb_subsection"><a name="CreateP2PConnectionSocket"></a>CreateP2PConnectionSocket</h2>
<div class="bb_code cpp">
    SNetSocket_t CreateP2PConnectionSocket( CSteamID steamIDTarget, int nVirtualPort, int
    nTimeoutSec, bool bAllowUseOfPacketRelay );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>steamIDTarget</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>nVirtualPort</strong></td>
            <td>int</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>nTimeoutSec</strong></td>
            <td>int</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>bAllowUseOfPacketRelay</strong></td>
            <td>bool</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Creates a socket and begin connection to a remote destination.<br />
<br />
can connect via a known Steam ID (client or game server), or directly to an IP<br />
on success will trigger a SocketStatusCallback_t callback<br />
on failure or timeout will trigger a SocketStatusCallback_t callback with a failure code in
m_eSNetSocketState<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model it's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> <a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a>
<h2 class="bb_subsection"><a name="DestroyListenSocket"></a>DestroyListenSocket</h2>
<div class="bb_code cpp">
    bool DestroyListenSocket( SNetListenSocket_t hSocket, bool bNotifyRemoteEnd );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetListenSocket_t">SNetListenSocket_t</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>bNotifyRemoteEnd</strong></td>
            <td>bool</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Destroying a listen socket will automatically kill all the regular sockets generated from it.<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model. It's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> bool
<h2 class="bb_subsection"><a name="DestroySocket"></a>DestroySocket</h2>
<div class="bb_code cpp">bool DestroySocket( SNetSocket_t hSocket, bool bNotifyRemoteEnd );</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>bNotifyRemoteEnd</strong></td>
            <td>bool</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Disconnects the connection to the socket, if any, and invalidates the handle.<br />
<br />
any unread data on the socket will be thrown away<br />
if bNotifyRemoteEnd is set, socket will not be completely destroyed until the remote end
acknowledges the disconnect<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model it's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> bool
<h2 class="bb_subsection"><a name="GetListenSocketInfo"></a>GetListenSocketInfo</h2>
<div class="bb_code cpp">
    bool GetListenSocketInfo( SNetListenSocket_t hListenSocket, uint32 *pnIP, uint16 *pnPort );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hListenSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetListenSocket_t">SNetListenSocket_t</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pnIP</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a> *</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pnPort</strong></td>
            <td><a href="/doc/api/steam_api#uint16">uint16</a> *</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Returns which local port the listen socket is bound to.<br />
<br />
*pnIP and *pnPort will be 0 if the socket is set to listen for P2P connections only<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model. It's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> bool
<h2 class="bb_subsection"><a name="GetMaxPacketSize"></a>GetMaxPacketSize</h2>
<div class="bb_code cpp">int GetMaxPacketSize( SNetSocket_t hSocket );</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a></td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Gets the max packet size, in bytes.<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model it's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> int
<h2 class="bb_subsection"><a name="GetP2PSessionState"></a>GetP2PSessionState</h2>
<div class="bb_code cpp">
    bool GetP2PSessionState( CSteamID steamIDRemote, P2PSessionState_t *pConnectionState );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>steamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a></td>
            <td>The user to get the active session state information of.</td>
        </tr>
        <tr>
            <td><strong>pConnectionState</strong></td>
            <td><a href="/doc/api/ISteamNetworking#P2PSessionState_t">P2PSessionState_t</a> *</td>
            <td>Returns the state.</td>
        </tr>
    </tbody>
</table>
<br />
Fills out a <a href="/doc/api/ISteamNetworking#P2PSessionState_t">P2PSessionState_t</a> structure
with details about the connection like whether or not there is an active connection; number of bytes
queued on the connection; the last error code, if any; whether or not a relay server is being used;
and the IP and Port of the remote user, if known<br />
<br />
This should only needed for debugging purposes.<br />
<br />
<strong>Returns:</strong> bool<br />
<strong>true</strong> if
<code class="bb_code bb_code_inline nohighlight">pConnectionState</code> was filled out; otherwise,
<strong>false</strong> if there was no open session with the specified user.<br />
<br />
<strong>Example:</strong><br />
<div class="bb_code cpp">
    P2PSessionState_t p2pSessionState; SteamNetworking()-&gt;GetP2PSessionState( steamIDremote,
    &amp;p2pSessionState );
</div>
<h2 class="bb_subsection"><a name="GetSocketConnectionType"></a>GetSocketConnectionType</h2>
<div class="bb_code cpp">
    ESNetSocketConnectionType GetSocketConnectionType( SNetSocket_t hSocket );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a></td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Returns true to describe how the socket ended up connecting.<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model. It's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong>
<a href="/doc/api/ISteamNetworking#ESNetSocketConnectionType">ESNetSocketConnectionType</a>
<h2 class="bb_subsection"><a name="GetSocketInfo"></a>GetSocketInfo</h2>
<div class="bb_code cpp">
    bool GetSocketInfo( SNetSocket_t hSocket, CSteamID *pSteamIDRemote, int *peSocketStatus, uint32
    *punIPRemote, uint16 *punPortRemote );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pSteamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a> *</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>peSocketStatus</strong></td>
            <td>int *</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>punIPRemote</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a> *</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>punPortRemote</strong></td>
            <td><a href="/doc/api/steam_api#uint16">uint16</a> *</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Returns information about the specified socket, filling out the contents of the pointers.<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model it's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> bool
<h2 class="bb_subsection"><a name="IsDataAvailable"></a>IsDataAvailable</h2>
<div class="bb_code cpp">
    bool IsDataAvailable( SNetListenSocket_t hListenSocket, uint32 *pcubMsgSize, SNetSocket_t
    *phSocket );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hListenSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetListenSocket_t">SNetListenSocket_t</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pcubMsgSize</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a> *</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>phSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a> *</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Checks for data from any socket that has been connected off this listen socket.<br />
<br />
returns false if there is no data remaining<br />
fills out *pcubMsgSize with the size of the next message, in bytes<br />
fills out *phSocket with the socket that data is available on<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model. It's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> bool
<h2 class="bb_subsection"><a name="IsDataAvailableOnSocket"></a>IsDataAvailableOnSocket</h2>
<div class="bb_code cpp">
    bool IsDataAvailableOnSocket( SNetSocket_t hSocket, uint32 *pcubMsgSize );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pcubMsgSize</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a> *</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Returns false if there is no data remaining.<br />
<br />
fills out *pcubMsgSize with the size of the next message, in bytes<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model it's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> bool
<h2 class="bb_subsection"><a name="IsP2PPacketAvailable"></a>IsP2PPacketAvailable</h2>
<div class="bb_code cpp">bool IsP2PPacketAvailable( uint32 *pcubMsgSize, int nChannel = 0 );</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>pcubMsgSize</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a> *</td>
            <td>Returns the size of the packet.</td>
        </tr>
        <tr>
            <td><strong>nChannel</strong></td>
            <td>int</td>
            <td>The channel to check if a packet is available in.</td>
        </tr>
    </tbody>
</table>
<br />
Checks if a P2P packet is available to read, and gets the size of the message if there is one.<br />
<br />
This should be called in a loop for each channel that you use. If there is a packet available you
should call <a href="/doc/api/ISteamNetworking#ReadP2PPacket">ISteamNetworking::ReadP2PPacket</a> to
get the packet data.<br />
<br />
<strong>Returns:</strong> bool<br />
<strong>true</strong> if there is a packet available; otherwise, <strong>false</strong>.
<h2 class="bb_subsection"><a name="ReadP2PPacket"></a>ReadP2PPacket</h2>
<div class="bb_code cpp">
    bool ReadP2PPacket( void *pubDest, uint32 cubDest, uint32 *pcubMsgSize, CSteamID
    *psteamIDRemote, int nChannel = 0 );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>pubDest</strong></td>
            <td>void *</td>
            <td>Returns the packet data by copying it into this buffer.</td>
        </tr>
        <tr>
            <td><strong>cubDest</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td>
                The size allocated for
                <code class="bb_code bb_code_inline nohighlight">pubDest</code>. This should be
                either the same size returned by
                <a href="/doc/api/ISteamNetworking#IsP2PPacketAvailable"
                    >ISteamNetworking::IsP2PPacketAvailable</a
                >, or the size of your largest packet.
            </td>
        </tr>
        <tr>
            <td><strong>pcubMsgSize</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a> *</td>
            <td>Returns the size of the packet.</td>
        </tr>
        <tr>
            <td><strong>psteamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a> *</td>
            <td>Returns the Steam ID of the user that sent this packet.</td>
        </tr>
        <tr>
            <td><strong>nChannel</strong></td>
            <td>int</td>
            <td>The channel the packet was sent over.</td>
        </tr>
    </tbody>
</table>
<br />
Reads in a packet that has been sent from another user via
<a href="/doc/api/ISteamNetworking#SendP2PPacket">ISteamNetworking::SendP2PPacket</a>.<br />
<br />
<br />
If the <code class="bb_code bb_code_inline nohighlight">cubDest</code> buffer is too small for the
packet, then the message will be truncated.<br />
<br />
This call is not blocking, and will return false if no data is available.<br />
<br />
Before calling this you should have called
<a href="/doc/api/ISteamNetworking#IsP2PPacketAvailable">ISteamNetworking::IsP2PPacketAvailable</a
>.<br />
<br />
<strong>Returns:</strong> bool<br />
<strong>true</strong> if a packet was successfully read; otherwise, <strong>false</strong> if no
packet was available.<br />
<br />
<strong>Example:</strong><br />
<div class="bb_code cpp">
    uint32 msgSize = 0; while ( SteamNetworking()-&gt;IsP2PPacketAvailable( &amp;msgSize ) ) { void
    *packet = malloc( msgSize ); CSteamID steamIDRemote; uint32 bytesRead = 0; if (
    SteamNetworking()-&gt;ReadP2PPacket( packet, msgSize, &amp;bytesRead, &amp;steamIDRemote ) ) {
    // message dispatch code goes here } free( packet ); }
</div>
<h2 class="bb_subsection"><a name="RetrieveData"></a>RetrieveData</h2>
<div class="bb_code cpp">
    bool RetrieveData( SNetListenSocket_t hListenSocket, void *pubDest, uint32 cubDest, uint32
    *pcubMsgSize, SNetSocket_t *phSocket );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hListenSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetListenSocket_t">SNetListenSocket_t</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pubDest</strong></td>
            <td>void *</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>cubDest</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pcubMsgSize</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a> *</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>phSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a> *</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Retrieves data from any socket that has been connected off this listen socket.<br />
<br />
fills in pubDest with the contents of the message<br />
messages are always complete, of the same size as was sent (i.e. packetized, not streaming)<br />
if *pcubMsgSize &lt; cubDest, only partial data is written<br />
returns false if no data is available<br />
fills out *phSocket with the socket that data is available on<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model. It's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> bool
<h2 class="bb_subsection"><a name="RetrieveDataFromSocket"></a>RetrieveDataFromSocket</h2>
<div class="bb_code cpp">
    bool RetrieveDataFromSocket( SNetSocket_t hSocket, void *pubDest, uint32 cubDest, uint32
    *pcubMsgSize );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pubDest</strong></td>
            <td>void *</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>cubDest</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pcubMsgSize</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a> *</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
Fills in pubDest with the contents of the message.<br />
<br />
messages are always complete, of the same size as was sent (i.e. packetized, not streaming)<br />
if *pcubMsgSize &lt; cubDest, only partial data is written<br />
returns false if no data is available<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model it's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<strong>Returns:</strong> bool
<h2 class="bb_subsection"><a name="SendDataOnSocket"></a>SendDataOnSocket</h2>
<div class="bb_code cpp">
    bool SendDataOnSocket( SNetSocket_t hSocket, void *pubData, uint32 cubData, bool bReliable );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>hSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>pubData</strong></td>
            <td>void *</td>
            <td></td>
        </tr>
        <tr>
            <td><strong>cubData</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td></td>
        </tr>
        <tr>
            <td><strong>bReliable</strong></td>
            <td>bool</td>
            <td></td>
        </tr>
    </tbody>
</table>
<br />
sending data<br />
must be a handle to a connected socket<br />
data is all sent via UDP, and thus send sizes are limited to 1200 bytes; after this, many routers
will start dropping packets<br />
use the reliable flag with caution; although the resend rate is pretty aggressive,<br />
it can still cause stalls in receiving data (like TCP)<br />
<br />
<strong>Returns:</strong> bool
<h2 class="bb_subsection"><a name="SendP2PPacket"></a>SendP2PPacket</h2>
<div class="bb_code cpp">
    bool SendP2PPacket( CSteamID steamIDRemote, const void *pubData, uint32 cubData, EP2PSend
    eP2PSendType, int nChannel = 0 );
</div>
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>steamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a></td>
            <td>The target user to send the packet to.</td>
        </tr>
        <tr>
            <td><strong>pubData</strong></td>
            <td>const void *</td>
            <td>
                The raw byte array for the packet data to send. The maximum size of this packet is
                defined by <code class="bb_code bb_code_inline nohighlight">eP2PSendType</code>.
            </td>
        </tr>
        <tr>
            <td><strong>cubData</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td>
                The size in bytes of
                <code class="bb_code bb_code_inline nohighlight">pubData</code>.
            </td>
        </tr>
        <tr>
            <td><strong>eP2PSendType</strong></td>
            <td><a href="/doc/api/ISteamNetworking#EP2PSend">EP2PSend</a></td>
            <td>
                Specifies how you want the data to be transmitted, such as reliably, unreliable,
                buffered, etc.
            </td>
        </tr>
        <tr>
            <td><strong>nChannel</strong></td>
            <td>int</td>
            <td>
                The channel which acts as a virtual port to send this packet on and allows you help
                route message to different systems.<br />
                You'll have to call
                <a href="/doc/api/ISteamNetworking#ReadP2PPacket"
                    >ISteamNetworking::ReadP2PPacket</a
                >
                on the other end with the same channel number in order to retrieve the data on the
                other end. Using different channels to talk to the same user will still use the same
                underlying P2P connection, saving on resources.<br />
                Use <strong>0</strong> for the primary channel, or if you do not use this feature.
            </td>
        </tr>
    </tbody>
</table>
<br />
Sends a P2P packet to the specified user.<br />
<br />
This is a session-less API which automatically establishes NAT-traversing or Steam relay server
connections.<br />
<br />
<strong>NOTE:</strong> The first packet send may be delayed as the NAT-traversal code runs.<br />
<br />
See <a href="/doc/api/ISteamNetworking#EP2PSend">EP2PSend</a> for descriptions of the different ways
of sending packets.<br />
<br />
The type of data you send is arbitrary, you can use an off the shelf system like
<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noreferrer"
    >Protocol Buffers</a
>
or <a href="https://capnproto.org" target="_blank" rel="noreferrer">Cap'n Proto</a> to encode your
packets in an efficient way, or you can create your own messaging system.<br />
<br />
<strong>Returns:</strong> bool<br />
Triggers a
<a href="/doc/api/ISteamNetworking#P2PSessionRequest_t">P2PSessionRequest_t</a> callback.<br />
<strong>true</strong> if the packet was successfully sent.<br />
Note that this does not mean successfully received, if we can't get through to the user after a
timeout of 20 seconds, then an error will be posted via the
<a href="/doc/api/ISteamNetworking#P2PSessionConnectFail_t">P2PSessionConnectFail_t</a>
callback.<br />
<br />
<strong>false</strong> upon the following conditions:<br />
<ul>
    <li>The packet is too large for the send type.<br /></li>
    <li>The target Steam ID is not valid.<br /></li>
    <li>There are too many bytes queued up to be sent.</li>
</ul>
<h2 class="bb_section"><a name="callbacks"></a>Callbacks</h2>
These are callbacks which can be fired by calling
<a href="/doc/api/steam_api#SteamAPI_RunCallbacks">SteamAPI_RunCallbacks</a>. Many of these will be
fired directly in response to the member functions of
<code class="bb_code bb_code_inline nohighlight">ISteamNetworking</code>.
<h2 class="bb_subsection"><a name="P2PSessionConnectFail_t"></a>P2PSessionConnectFail_t</h2>
Called when packets can't get through to the specified user.<br />
All queued packets unsent at this point will be dropped, further attempts to send will retry making
the connection (but will be dropped if we fail again).<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>m_steamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a></td>
            <td>User we were trying to send the packets to.</td>
        </tr>
        <tr>
            <td><strong>m_eP2PSessionError</strong></td>
            <td><a href="/doc/api/steam_api#uint8">uint8</a></td>
            <td>
                Indicates the reason why we're having trouble. Actually a
                <a href="/doc/api/ISteamNetworking#EP2PSessionError">EP2PSessionError</a>.
            </td>
        </tr>
    </tbody>
</table>
<h2 class="bb_subsection"><a name="P2PSessionRequest_t"></a>P2PSessionRequest_t</h2>
A user wants to communicate with us over the P2P channel via the
<a href="/doc/api/ISteamNetworking#SendP2PPacket">ISteamNetworking::SendP2PPacket</a>. In response,
a call to
<a href="/doc/api/ISteamNetworking#AcceptP2PSessionWithUser"
    >ISteamNetworking::AcceptP2PSessionWithUser</a
>
needs to be made, if you want to open the network channel with them.<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>m_steamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a></td>
            <td>The user who wants to start a P2P session with us.</td>
        </tr>
    </tbody>
</table>
<br />
<strong>Associated Functions:</strong>
<a href="/doc/api/ISteamNetworking#SendP2PPacket">ISteamNetworking::SendP2PPacket</a>
<h2 class="bb_subsection"><a name="SocketStatusCallback_t"></a>SocketStatusCallback_t</h2>
Called when the status of a socket has changed, used as part of the
<a href="/doc/api/ISteamNetworking#CreateListenSocket">ISteamNetworking::CreateListenSocket</a> and
<a href="/doc/api/ISteamNetworking#CreateP2PConnectionSocket"
    >ISteamNetworking::CreateP2PConnectionSocket</a
>
calls.<br />
<br />
This is part of an older set of functions designed around the Berkeley TCP sockets model. It's
preferential that you use the P2P functions, they're more robust and these older functions will be
removed eventually.<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>m_hSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetSocket_t">SNetSocket_t</a></td>
            <td>the socket used to send/receive data to the remote host</td>
        </tr>
        <tr>
            <td><strong>m_hListenSocket</strong></td>
            <td><a href="/doc/api/ISteamNetworking#SNetListenSocket_t">SNetListenSocket_t</a></td>
            <td>
                this is the server socket that we were listening on; NULL if this was an outgoing
                connection
            </td>
        </tr>
        <tr>
            <td><strong>m_steamIDRemote</strong></td>
            <td><a href="/doc/api/steam_api#CSteamID">CSteamID</a></td>
            <td>remote Steam ID we have connected to, if it has one</td>
        </tr>
        <tr>
            <td><strong>m_eSNetSocketState</strong></td>
            <td>int</td>
            <td>socket state, ESNetSocketState</td>
        </tr>
    </tbody>
</table>
<h2 class="bb_section"><a name="structs"></a>Structs</h2>
These are structs which functions in ISteamNetworking may return and/or interact with.
<h2 class="bb_subsection"><a name="P2PSessionState_t"></a>P2PSessionState_t</h2>
Connection state to a specified user, returned by
<a href="/doc/api/ISteamNetworking#GetP2PSessionState">ISteamNetworking::GetP2PSessionState</a>.
This is the under-the-hood info about what's going on with a previous call to
<a href="/doc/api/ISteamNetworking#SendP2PPacket">ISteamNetworking::SendP2PPacket</a>. This
typically shouldn't be needed except for debugging purposes.<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>m_bConnectionActive</strong></td>
            <td><a href="/doc/api/steam_api#uint8">uint8</a></td>
            <td>
                Do we have an active open connection with the user (<strong>true</strong>) or not
                (<strong>false</strong>)?
            </td>
        </tr>
        <tr>
            <td><strong>m_bConnecting</strong></td>
            <td><a href="/doc/api/steam_api#uint8">uint8</a></td>
            <td>
                Are we currently trying to establish a connection with the user
                (<strong>true</strong>) or not (<strong>false</strong>)?
            </td>
        </tr>
        <tr>
            <td><strong>m_eP2PSessionError</strong></td>
            <td><a href="/doc/api/steam_api#uint8">uint8</a></td>
            <td>
                Last error recorded on the socket. This returns a
                <a href="/doc/api/ISteamNetworking#EP2PSessionError">EP2PSessionError</a>.
            </td>
        </tr>
        <tr>
            <td><strong>m_bUsingRelay</strong></td>
            <td><a href="/doc/api/steam_api#uint8">uint8</a></td>
            <td>
                Is this connection going through a Steam relay server (<strong>true</strong>) or not
                (<strong>false</strong>)?
            </td>
        </tr>
        <tr>
            <td><strong>m_nBytesQueuedForSend</strong></td>
            <td><a href="/doc/api/steam_api#int32">int32</a></td>
            <td>The number of bytes queued up to be sent to the user.</td>
        </tr>
        <tr>
            <td><strong>m_nPacketsQueuedForSend</strong></td>
            <td><a href="/doc/api/steam_api#int32">int32</a></td>
            <td>The number of packets queued up to be sent to the user.</td>
        </tr>
        <tr>
            <td><strong>m_nRemoteIP</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td>
                The IP of remote host if set. Could be a Steam relay server. This only exists for
                compatibility with older authentication api's.
            </td>
        </tr>
        <tr>
            <td><strong>m_nRemotePort</strong></td>
            <td><a href="/doc/api/steam_api#uint16">uint16</a></td>
            <td>
                The Port of remote host if set. Could be a Steam relay server. This only exists for
                compatibility with older authentication api's.
            </td>
        </tr>
    </tbody>
</table>
<h2 class="bb_section"><a name="enums"></a>Enums</h2>
These are enums which are defined for use with ISteamNetworking.
<h2 class="bb_subsection"><a name="EP2PSend"></a>EP2PSend</h2>
Specifies the send type of
<a href="/doc/api/ISteamNetworking#SendP2PPacket">ISteamNetworking::SendP2PPacket</a>.<br />
Typically <code class="bb_code bb_code_inline nohighlight">k_EP2PSendUnreliable</code> is what you
want for UDP-like packets,
<code class="bb_code bb_code_inline nohighlight">k_EP2PSendReliable</code> for TCP-like packets<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Value</th>
            <th>Description</th>
        </tr>
        <tr id="k_EP2PSendUnreliable">
            <td><strong>k_EP2PSendUnreliable</strong></td>
            <td>0</td>
            <td>
                Basic UDP send. Packets can't be bigger than 1200 bytes (your typical MTU size). Can
                be lost, or arrive out of order (rare).<br />
                The sending API does have some knowledge of the underlying connection, so if there
                is no NAT-traversal accomplished or there is a recognized adjustment happening on
                the connection, the packet will be batched until the connection is open again.
            </td>
        </tr>
        <tr id="k_EP2PSendUnreliableNoDelay">
            <td><strong>k_EP2PSendUnreliableNoDelay</strong></td>
            <td>1</td>
            <td>
                As above, but if the underlying P2P connection isn't yet established the packet will
                just be thrown away. Using this on the first packet sent to a remote host almost
                guarantees the packet will be dropped.<br />
                This is only really useful for kinds of data that should never buffer up, i.e. voice
                payload packets
            </td>
        </tr>
        <tr id="k_EP2PSendReliable">
            <td><strong>k_EP2PSendReliable</strong></td>
            <td>2</td>
            <td>
                Reliable message send. Can send up to 1MB of data in a single message.<br />
                Does fragmentation/re-assembly of messages under the hood, as well as a sliding
                window for efficient sends of large chunks of data.
            </td>
        </tr>
        <tr id="k_EP2PSendReliableWithBuffering">
            <td><strong>k_EP2PSendReliableWithBuffering</strong></td>
            <td>3</td>
            <td>
                As above, but applies the Nagle algorithm to the send - sends will accumulate until
                the current MTU size (typically ~1200 bytes, but can change) or ~200ms has passed
                (Nagle algorithm).<br />
                This is useful if you want to send a set of smaller messages but have the coalesced
                into a single packet.<br />
                Since the reliable stream is all ordered, you can do several small message sends
                with
                <code class="bb_code bb_code_inline nohighlight"
                    >k_EP2PSendReliableWithBuffering</code
                >
                and then do a normal k_EP2PSendReliable to force all the buffered data to be sent.
            </td>
        </tr>
    </tbody>
</table>
<h2 class="bb_subsection"><a name="EP2PSessionError"></a>EP2PSessionError</h2>
List of possible errors returned by
<a href="/doc/api/ISteamNetworking#SendP2PPacket">ISteamNetworking::SendP2PPacket</a>, these will be
sent in the
<a href="/doc/api/ISteamNetworking#P2PSessionConnectFail_t">P2PSessionConnectFail_t</a>
callback.<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Value</th>
            <th>Description</th>
        </tr>
        <tr id="k_EP2PSessionErrorNone">
            <td><strong>k_EP2PSessionErrorNone</strong></td>
            <td>0</td>
            <td>There was no error.</td>
        </tr>
        <tr id="k_EP2PSessionErrorNotRunningApp">
            <td><strong>k_EP2PSessionErrorNotRunningApp</strong></td>
            <td>1</td>
            <td>The target user is not running the same game.</td>
        </tr>
        <tr id="k_EP2PSessionErrorNoRightsToApp">
            <td><strong>k_EP2PSessionErrorNoRightsToApp</strong></td>
            <td>2</td>
            <td>The local user doesn't own the app that is running.</td>
        </tr>
        <tr id="k_EP2PSessionErrorDestinationNotLoggedIn">
            <td><strong>k_EP2PSessionErrorDestinationNotLoggedIn</strong></td>
            <td>3</td>
            <td>Target user isn't connected to Steam.</td>
        </tr>
        <tr id="k_EP2PSessionErrorTimeout">
            <td><strong>k_EP2PSessionErrorTimeout</strong></td>
            <td>4</td>
            <td>
                The connection timed out because the target user didn't respond, perhaps they aren't
                calling
                <a href="/doc/api/ISteamNetworking#AcceptP2PSessionWithUser"
                    >ISteamNetworking::AcceptP2PSessionWithUser</a
                >.<br />
                Corporate firewalls can also block this (NAT traversal is not firewall traversal),
                make sure that UDP ports 3478, 4379, and 4380 are open in an outbound direction.
            </td>
        </tr>
        <tr id="k_EP2PSessionErrorMax">
            <td><strong>k_EP2PSessionErrorMax</strong></td>
            <td>5</td>
            <td>Unused.</td>
        </tr>
    </tbody>
</table>
<h2 class="bb_subsection"><a name="ESNetSocketConnectionType"></a>ESNetSocketConnectionType</h2>
Describes how the socket is currently connected. Only used by the old networking API.<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Value</th>
            <th>Description</th>
        </tr>
        <tr id="k_ESNetSocketConnectionTypeNotConnected">
            <td><strong>k_ESNetSocketConnectionTypeNotConnected</strong></td>
            <td>0</td>
            <td></td>
        </tr>
        <tr id="k_ESNetSocketConnectionTypeUDP">
            <td><strong>k_ESNetSocketConnectionTypeUDP</strong></td>
            <td>1</td>
            <td></td>
        </tr>
        <tr id="k_ESNetSocketConnectionTypeUDPRelay">
            <td><strong>k_ESNetSocketConnectionTypeUDPRelay</strong></td>
            <td>2</td>
            <td></td>
        </tr>
    </tbody>
</table>
<h2 class="bb_subsection"><a name="ESNetSocketState"></a>ESNetSocketState</h2>
Connection progress indicators, used by
<a href="/doc/api/ISteamNetworking#CreateP2PConnectionSocket"
    >ISteamNetworking::CreateP2PConnectionSocket</a
>.<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Value</th>
            <th>Description</th>
        </tr>
        <tr id="k_ESNetSocketStateInvalid">
            <td><strong>k_ESNetSocketStateInvalid</strong></td>
            <td>0</td>
            <td></td>
        </tr>
        <tr id="k_ESNetSocketStateConnected">
            <td><strong>k_ESNetSocketStateConnected</strong></td>
            <td>1</td>
            <td>communication is valid</td>
        </tr>
        <tr id="k_ESNetSocketStateInitiated">
            <td><strong>k_ESNetSocketStateInitiated</strong></td>
            <td>10</td>
            <td>
                states while establishing a connection<br />
                the connection state machine has started
            </td>
        </tr>
        <tr id="k_ESNetSocketStateLocalCandidatesFound">
            <td><strong>k_ESNetSocketStateLocalCandidatesFound</strong></td>
            <td>11</td>
            <td>
                p2p connections<br />
                we've found our local IP info
            </td>
        </tr>
        <tr id="k_ESNetSocketStateReceivedRemoteCandidates">
            <td><strong>k_ESNetSocketStateReceivedRemoteCandidates</strong></td>
            <td>12</td>
            <td>
                we've received information from the remote machine, via the Steam back-end, about
                their IP info
            </td>
        </tr>
        <tr id="k_ESNetSocketStateChallengeHandshake">
            <td><strong>k_ESNetSocketStateChallengeHandshake</strong></td>
            <td>15</td>
            <td>
                direct connections<br />
                we've received a challenge packet from the server
            </td>
        </tr>
        <tr id="k_ESNetSocketStateDisconnecting">
            <td><strong>k_ESNetSocketStateDisconnecting</strong></td>
            <td>21</td>
            <td>
                failure states<br />
                the API shut it down, and we're in the process of telling the other end
            </td>
        </tr>
        <tr id="k_ESNetSocketStateLocalDisconnect">
            <td><strong>k_ESNetSocketStateLocalDisconnect</strong></td>
            <td>22</td>
            <td>the API shut it down, and we've completed shutdown</td>
        </tr>
        <tr id="k_ESNetSocketStateTimeoutDuringConnect">
            <td><strong>k_ESNetSocketStateTimeoutDuringConnect</strong></td>
            <td>23</td>
            <td>we timed out while trying to creating the connection</td>
        </tr>
        <tr id="k_ESNetSocketStateRemoteEndDisconnected">
            <td><strong>k_ESNetSocketStateRemoteEndDisconnected</strong></td>
            <td>24</td>
            <td>the remote end has disconnected from us</td>
        </tr>
        <tr id="k_ESNetSocketStateConnectionBroken">
            <td><strong>k_ESNetSocketStateConnectionBroken</strong></td>
            <td>25</td>
            <td>
                connection has been broken; either the other end has disappeared or our local
                network connection has broke
            </td>
        </tr>
    </tbody>
</table>
<h2 class="bb_section"><a name="typedefs"></a>Typedefs</h2>
These are typedefs which are defined for use with ISteamNetworking.<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Base type</th>
            <th>Description</th>
        </tr>
        <tr id="SNetListenSocket_t">
            <td><strong>SNetListenSocket_t</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td>CreateListenSocket()</td>
        </tr>
        <tr id="SNetSocket_t">
            <td><strong>SNetSocket_t</strong></td>
            <td><a href="/doc/api/steam_api#uint32">uint32</a></td>
            <td>
                handle to a socket<br />
                CreateP2PConnectionSocket()
            </td>
        </tr>
    </tbody>
</table>
<h2 class="bb_section"><a name="constants"></a>Constants</h2>
These are constants which are defined for use with ISteamNetworking.<br />
<br />
<table>
    <tbody>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Value</th>
            <th>Description</th>
        </tr>
        <tr id="STEAMNETWORKING_INTERFACE_VERSION">
            <td><strong>STEAMNETWORKING_INTERFACE_VERSION</strong></td>
            <td>const char *</td>
            <td>"SteamNetworking005"</td>
            <td></td>
        </tr>
    </tbody>
</table>
